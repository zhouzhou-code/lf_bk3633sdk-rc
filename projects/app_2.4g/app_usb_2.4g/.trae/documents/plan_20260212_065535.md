您说得对，Slave 确实不应该关心自己被分配到哪个通道，这完全是 Host 的“内政”。Slave 只需要告诉 Host “我是谁”（Slave ID），然后 Host 根据这个 ID 查表或执行逻辑判断，决定把它安排在 Pipe 0 还是 Pipe 5。

### 1. 核心逻辑转变：Host 主导分配

**Slave 的职责**：

* 发送 `CMD_PAIR_REQ`，包含自己的 `slave_id`（设备类型 + 唯一码）。

* 等待 Host 分配地址。

**Host 的职责**：

* 收到请求，解析 `slave_id`。

* **查表/决策**：根据 ID 判断设备类型。

  * 例如：ID 以 `0x01` 开头的是“左手手柄”，必须分配给 Pipe 2。

  * ID 以 `0x02` 开头的是“右手手柄”，必须分配给 Pipe 3。

* **执行分配**：调用 `app_addr_pair_pipe(target_pipe)` 生成对应通道的地址。

* **下发配置**：将生成的地址发回给 Slave。

### 2. 实现细节

#### A. 设备 ID 映射策略 (示例)

我们需要在 `rf_pair.c` 中硬编码或配置一个映射逻辑。为了演示，我们将采用简单的**ID 前缀映射**：

* `0x10xxxxxx` -> 分配给 Pipe 0 (主设备)

* `0x11xxxxxx` -> 分配给 Pipe 1 (基准设备)

* `0x12xxxxxx` -> 分配给 Pipe 2

* ...

* 其他/未知 -> 拒绝配对或分配给默认通道。

#### B. `rf_pair.c` 逻辑重构

**`Host_Pairing_Task`** **修改点**：

1. **解析请求**：从 `recv_req->slave_id` 提取特征。
2. **决策 Pipe**：

   ```c
   uint8_t target_pipe = 0;
   uint8_t id_prefix = (recv_req->slave_id >> 24) & 0xFF;

   // 示例映射逻辑
   if (id_prefix == 0x10) target_pipe = 0;
   else if (id_prefix == 0x11) target_pipe = 1;
   else if (id_prefix == 0x12) target_pipe = 2;
   // ...
   else {
       // 未知设备，忽略或分配给保留通道
       return; 
   }
   ```
3. **调用分配接口**：

   ```c
   uint8_t new_addr[5];
   if (app_addr_pair_pipe(target_pipe, new_addr)) {
       // 填充响应包
       memcpy(g_host_ctrl.resp_pkt.new_addr, new_addr, 5);
       // ... 发送响应 ...
   }
   ```

### 3. 执行计划

1. **无需修改协议**：`pair_req_pkt` 保持原样（只含 `slave_id`），不需要增加 `target_pipe` 字段。
2. **实现 Host 决策函数**：在 `rf_pair.c` 中增加 `get_pipe_by_slave_id(uint32_t id)` 辅助函数。
3. **集成地址分配**：在 Host 收到 REQ 后，先调用决策函数得到 Pipe ID，再调用 `app_addr_pair_pipe` 生成地址。
4. **验证**：模拟不同 ID 的 Slave 发起请求，观察 Host 是否将其分配到了正确的 Pipe 并生成了合法的地址（Pipe 2-5 共享高位）。

