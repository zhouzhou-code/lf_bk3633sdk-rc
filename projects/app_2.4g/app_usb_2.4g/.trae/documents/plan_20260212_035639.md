我将为您创建一个统一的 `app_addr_manage` 模块，用于集中管理 RF 相关的地址逻辑。这个模块将解决地址分类混乱、发送时地址切换繁琐以及 Flash 存储管理的问题。

### 1. 模块设计思路

我们将地址分为三类进行管理：
1.  **静态配置地址**：如出厂默认配对地址（硬编码）。
2.  **持久化配对地址**：存储在 Flash 中的已配对地址。
3.  **运行时通道地址**：当前 RF 寄存器中 6 个 Pipe 的实际配置。

### 2. 核心功能规划

#### A. 数据结构 (`app_addr_manage.h`)
定义一个管理结构体，包含：
*   `default_addr`: 默认配对地址（只读）。
*   `paired_addr`: 从 Flash 加载的配对地址。
*   `pipe_cfg[6]`: 6 个接收通道的当前地址缓存。
*   `backup_pipe0`: 用于发送时临时备份 Pipe0 地址。
*   `is_paired`: 标记是否已配对。

#### B. API 接口 (`app_addr_manage.c`)

1.  **初始化与加载**
    *   `app_addr_init()`: 初始化模块，尝试从 Flash 读取配对信息。如果 Flash 为空或校验失败，使用默认地址填充。
    *   `app_addr_is_paired()`: 查询当前是否已配对。

2.  **地址获取与设置**
    *   `app_addr_get_default(uint8_t *buf)`: 获取硬编码默认地址。
    *   `app_addr_get_current(uint8_t *buf)`: 获取当前工作地址（已配对则返回配对地址，否则返回默认）。
    *   `app_addr_update_pair(uint8_t *new_addr)`: 更新配对地址，并自动写入 Flash。

3.  **RF 通道管理 (解决“各个接收通道”问题)**
    *   `app_addr_set_pipe(uint8_t pipe_id, uint8_t *addr)`: 设置指定通道的逻辑地址（自动处理 Pipe 2-5 仅低字节有效的硬件限制）。
    *   `app_addr_apply_to_rf()`: 将所有缓存的通道地址写入 RF 硬件寄存器。

4.  **发送时的临时切换 (解决“发送时切换”痛点)**
    *   `app_addr_tx_prepare(uint8_t *tx_addr)`: 
        *   备份当前 Pipe0 地址。
        *   设置 RF TX 地址为 `tx_addr`。
        *   设置 RF Pipe0 地址为 `tx_addr` (为了接收 ACK)。
    *   `app_addr_tx_restore()`: 
        *   恢复 Pipe0 地址为备份值。
        *   (可选) 恢复 TX 地址为默认。

### 3. 实现步骤

1.  **创建文件**: 在 `app/src/remote_control/` 下创建 `app_addr_manage.h` 和 `app_addr_manage.c`。
2.  **移植逻辑**: 将 `rf_pair.c` 中的 Flash 读写逻辑和 `PAIR_ADDR_DEFAULT` 定义迁移或引用到新模块，避免重复定义。
3.  **实现状态机**: 编写上述 API 的具体实现。
4.  **集成**: 修改 `rf_pair.c` 和 `main.c`，将散落的地址操作替换为调用此模块的 API。

### 4. 验证计划
*   编写简单的测试代码，模拟“读取默认 -> 更新配对 -> 写入 Flash -> 重启读取”流程。
*   验证 `tx_prepare` 和 `tx_restore` 是否正确备份和恢复了 Pipe0 地址。

这个方案将复杂的地址操作封装在模块内部，外部只需调用 `prepare` 和 `restore` 即可安全发送，无需关心底层寄存器细节。
