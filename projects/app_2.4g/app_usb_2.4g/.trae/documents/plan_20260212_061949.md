您考虑得非常周全，地址池耗尽是必须面对的现实问题。如果只是简单地分配而不回收，有限的地址空间（特别是 Pipe 2-5 只有 256 个可能的 LSB，实际受限于位图可能更少）很快就会用完。

针对“防止重复”和“地址耗尽”这两个核心问题，我制定了以下策略：

### 1. 地址分配与回收策略

我们采用**“位图管理 + 循环复用”**的策略，结合**“强制重置”**机制。

*   **位图 (Bitmap)**：在 Flash 中维护一个 `uint32_t` 类型的位图（支持 32 个 ID，对于 6 个物理通道来说绰绰有余）。每一位代表一个 LSB 是否被占用。
*   **分配逻辑**：
    1.  优先寻找**当前未被使用**的最小 ID（从位图中查找第一个为 0 的位）。
    2.  如果位图全为 1（地址耗尽），则触发**回收/覆盖机制**。

### 2. 地址耗尽处理 (回收机制)

当地址池已满（例如 32 个 ID 全部分配出去）但又有新设备请求配对时，我们必须做出选择：

*   **策略 A：最旧覆盖 (LRU - Least Recently Used)**
    *   需要额外记录每个 ID 的“最后活跃时间”或“分配顺序”。这会显著增加 Flash 写入频率（每次通信都要更新时间戳），不太适合嵌入式 Flash。
*   **策略 B：循环覆盖 (Round Robin)**
    *   维护一个 `next_alloc_idx` 指针。当位图满时，直接覆盖 `next_alloc_idx` 指向的旧 ID，并将其分配给新设备。
    *   **优点**：实现简单，Flash 寿命友好。
    *   **缺点**：被覆盖的旧设备将突然断连（需重新配对），但这在“配对设备过多”场景下是合理的行为。
*   **策略 C (推荐)：基于物理通道的强制覆盖**
    *   考虑到作为 Host，物理接收通道只有 6 个（Pipe 0-5）。**我们实际上并不需要管理几百个配对设备，只需要管理“当前占用了这 6 个坑位”的设备。**
    *   **核心逻辑**：当用户指定为“Pipe X”配对时，**无条件生成新地址并覆盖 Pipe X 原有的地址**。
    *   **原因**：Host 同一时间只能监听 6 个地址。如果你为 Pipe 2 配对了一个新设备，那么旧的 Pipe 2 设备无论如何都无法再通信了（因为 Pipe 2 的监听地址已经变了）。**因此，我们不需要一个庞大的地址池来存储“离线设备”，只需要管理“当前在线的 6 个通道”。**

### 3. 修正后的最终方案 (基于“当前在线”原则)

既然硬件限制了同时只能有 6 个通道在线，那么“地址池”的概念其实可以简化：**Flash 只需要存储当前 6 个通道的配置即可，不需要额外的位图来管理“历史设备”。**

**防止重复的策略**：
每次为 Pipe X 生成新地址时，确保它不与当前其他 5 个 Pipe 的地址冲突即可。

**Flash 结构体 (`PairInfo_t`)**：
```c
typedef struct {
    uint32_t magic;
    
    // Pipe 0 & 1: 完整 5 字节
    uint8_t pipe0_addr[5]; 
    uint8_t pipe1_addr[5]; 

    // Pipe 2-5: 仅存储 LSB (高 4 字节强制等于 Pipe 1)
    uint8_t pipe2_lsb;
    uint8_t pipe3_lsb;
    uint8_t pipe4_lsb;
    uint8_t pipe5_lsb;

    // 有效位标记 (低 6 位分别代表 Pipe 0-5 是否有效)
    uint8_t valid_mask; 

    uint8_t checksum;
} PairInfo_t;
```

**配对逻辑 (解决耗尽与冲突)**：
*   **场景**：用户触发“Pipe 2 配对”。
*   **步骤**：
    1.  读取当前 Pipe 1 的高 4 字节（作为基准）。
    2.  **生成 LSB**：随机生成一个字节。
    3.  **冲突检测**：检查该 LSB 是否等于 Pipe 3, 4, 5 当前的 LSB，或者 Pipe 1 的 LSB。
    4.  **解决冲突**：如果相等，重新随机，直到找到一个不与**当前其他有效通道**冲突的值。
    5.  **覆盖**：将新 LSB 写入 `pipe2_lsb`，更新 Flash。旧的 Pipe 2 设备失效。

**这个方案的优势**：
*   **无需担心地址池耗尽**：因为我们只维护“当前 6 个席位”，永远只有 6 个有效数据，旧的自动被新配对的顶替。
*   **无需复杂位图**：冲突检测只需遍历 6 个通道。
*   **逻辑自洽**：符合 RF 芯片“同时只能监听 6 个地址”的物理事实。

### 4. 执行计划

1.  **定义简化版结构体**：如上所述，只存 6 个通道的当前状态。
2.  **实现冲突检测函数**：`bool is_addr_conflict(uint8_t *new_addr)`。
3.  **重写配对接口**：`app_addr_pair_pipe(uint8_t pipe_id)`，内部执行“生成 -> 查重 -> 覆盖”逻辑。
